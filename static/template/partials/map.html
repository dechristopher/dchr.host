<script src='https://unpkg.com/maplibre-gl@2.1.0/dist/maplibre-gl.js' crossorigin="anonymous"
				referrerpolicy="no-referrer"></script>
<script>
	const lat = '{{ .Lat }}';
	const lon = '{{ .Lon }}';
	const zoom = '{{ .Zoom }}';
	const pitch = '{{ .Pitch }}';
	const bearing = '{{ .Bearing }}';

	const getCenter = () => {
		if (lat === '' || lon === '') {
			return [-71.5, 42.2];
		}

		return [lon, lat];
	};

	const getZoom = () => {
		if (zoom === '0') {
			return 8;
		}

		return zoom;
	};

	const getPitch = () => {
		if (pitch === '0') {
			return 0;
		}

		return pitch;
	};

	const getBearing = () => {
		if (bearing === '0') {
			return 0;
		}

		return bearing;
	};

	let map = new maplibregl.Map({
		container: 'map',
		style: '/style.json',
		center: getCenter(),
		maxBounds: [
			[-74.92, 40.55],
			[-68.26, 43.42]
		],
		minZoom: 7,
		maxZoom: 19,
		maxPitch: 70,
		zoom: getZoom(),
		pitch: getPitch(),
		bearing: getBearing()
	});

	class ButtonControl {
		constructor({className = "", title = "", eventHandler = ()=>{}}) {
			this._className = className;
			this._title = title;
			this._eventHandler = eventHandler;
		}

		onAdd(map) {
			this._btn = document.createElement("button");
			this._btn.className = "maplibre-ctrl-icon mapboxgl-ctrl-icon" + " " + this._className;
			this._btn.type = "button";
			this._btn.title = this._title;
			this._btn.onclick = this._eventHandler;

			this._container = document.createElement("div");
			this._container.className = "maplibre-ctrl-group maplibre-ctrl mapboxgl-ctrl mapboxgl-ctrl-group";
			this._container.appendChild(this._btn);

			return this._container;
		}

		onRemove() {
			this._container.parentNode.removeChild(this._container);
			this._map = undefined;
		}
	}

	// map.showTileBoundaries = false;

	// Add zoom and rotation controls to the map.
	map.addControl(new maplibregl.NavigationControl({
		visualizePitch: true
	}));

	map.addControl(new ButtonControl({
		className: "maplibre-gl-show_tiles",
		title: "Show Debug Tiles",
		eventHandler: () => {
			map.showTileBoundaries = !map.showTileBoundaries;
		}
	}), "top-right");

	// Create a popup, but don't add it to the map yet.
	const popup = new maplibregl.Popup({
		closeButton: false,
		closeOnClick: false
	});

	map.on('mousemove', 'tornado_line_buffer', (e) => {
		// Change the cursor style to the UI indicator.
		map.getCanvas().style.cursor = 'pointer';

		const props = e.features[0].properties;

		const description = `<b>Time:</b> ${props.date} @ ${props.time}<br />`
			+ `<b>Damage:</b> F${props.mag} <b>Injuries:</b> ${props.inj}`;

		// Populate the popup and set its coordinates based on the feature found.
		popup.setLngLat(e.lngLat)
			.setHTML(description)
			.addTo(map);
	});

	map.on('mouseleave', 'tornado_line_buffer', () => {
		map.getCanvas().style.cursor = '';
		popup.remove();
	});

	// return pitch and bearing params if either are set
	let pitchBearing = () => {
		if (map.getPitch() > 0 || map.getBearing() !== 0 || map.getBearing() !== -0 || map.getBearing() !== 0.0 || map.getBearing() !== -0.0) {
			return `,${map.getPitch().toFixed(1)},${map.getBearing().toFixed(1)}`;
		}
		return '';
	}

	// debounce function generator
	const debounce = (func, wait, immediate) => {
		let timeout;
		return function () {
			let context = this, args = arguments;
			let later = function () {
				timeout = null;
				if (!immediate) func.apply(context, args);
			};
			let callNow = immediate && !timeout;
			clearTimeout(timeout);
			timeout = setTimeout(later, wait);
			if (callNow) func.apply(context, args);
		};
	};

	// debounce setting the map viewport in the URL
	const debounceUrl = debounce(() => {
		if (map) {
			let {lng, lat} = map.getCenter();
			let zoom = map.getZoom();
			window.history.replaceState(null, 'map',
				`/map/@${lat.toFixed(zoom / 3)},${lng.toFixed(zoom / 3)}`
				+ `,${zoom.toFixed(1)}z${pitchBearing()}`);
		}
	}, 250);

	map.on('move', debounceUrl);
</script>
